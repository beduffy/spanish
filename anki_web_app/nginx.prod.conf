# Basic HTTP context, which might be part of a larger nginx.conf file.
# For this standalone configuration, we'll imply its existence or let Nginx use defaults.

# Upstream block for the Django backend application.
# This allows for load balancing or easy updates to the backend server address.
upstream django_backend {
    # Assuming the Django backend service is named 'backend' and runs on port 8000 in a Docker environment.
    # If running Nginx and Django on the same host without Docker, this might be 127.0.0.1:8000.
    server backend:8000;
}

server {
    listen 80;
    # Replace with your actual domain name(s)
    server_name example.com www.example.com;

    # Paths for access and error logs.
    # These can be customized. Nginx defaults are often /var/log/nginx/access.log and /var/log/nginx/error.log.
    # In a Docker setup, these might be directed to stdout/stderr for easier log aggregation.
    access_log /var/log/nginx/prod_access.log;
    error_log /var/log/nginx/prod_error.log warn;

    # === SSL Configuration (Placeholder) ===
    # For production, SSL is highly recommended.
    # If using Certbot with Let's Encrypt, Certbot typically modifies the Nginx config automatically
    # to include SSL settings and a separate server block for port 443.
    #
    # Example of what Certbot might add or what you'd configure manually:
    #
    # listen 443 ssl http2;
    # server_name example.com www.example.com;
    #
    # ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;
    # ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;
    # include /etc/letsencrypt/options-ssl-nginx.conf; # Recommended SSL parameters
    # ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # Diffie-Hellman parameters
    #
    # # Redirect HTTP to HTTPS (usually placed in the port 80 server block if SSL is active on 443)
    # if ($scheme != "https") {
    #     return 301 https://$host$request_uri;
    # }
    # === End SSL Configuration Placeholder ===


    # === Basic Security Headers ===
    # These headers provide an extra layer of security.
    add_header X-Content-Type-Options nosniff;
    add_header X-XSS-Protection "1; mode=block";
    add_header X-Frame-Options "SAMEORIGIN"; # Prevents clickjacking if your app isn't designed to be iframed by others.
    add_header Referrer-Policy "strict-origin-when-cross-origin";
    # add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:;"; # Example CSP, needs careful tuning.


    # === Frontend (Vue.js SPA) Configuration ===
    # This location block serves the static files for the Vue.js single-page application.
    location / {
        # Path to the directory where your built Vue.js frontend files are located.
        # In a Docker setup, this path is relative to where you copy/mount the 'dist' folder in the Nginx container.
        root /var/www/frontend_dist; # Example: /app/frontend/dist or /usr/share/nginx/html/dist
        
        # Try to serve the requested file directly, then as a directory, 
        # and finally fall back to /index.html for SPA routing.
        try_files $uri $uri/ /index.html;

        # Caching for static assets.
        # Images, icons, video, audio, and fonts can often be cached for longer periods.
        location ~* \.(?:jpg|jpeg|gif|png|ico|cur|gz|svg|svgz|mp4|ogg|ogv|webm|htc|woff|woff2|ttf|eot)$ {
            expires 1M; # Cache for 1 month
            access_log off;
            add_header Cache-Control "public";
        }

        # JS and CSS files can be cached for a shorter period or use cache-busting techniques (e.g., webpack hashing).
        location ~* \.(?:css|js)$ {
            expires 7d; # Cache for 1 week
            access_log off;
            add_header Cache-Control "public";
        }
    }


    # === Backend (Django API) Reverse Proxy Configuration ===
    # This location block forwards requests starting with /api/ to the Django backend service.
    location /api/ {
        # Strip the /api/ prefix before forwarding, if your Django app's URLs don't include it.
        # If Django URLs are like /api/v1/endpoint, and Nginx location is /api/, then proxy_pass should be http://django_backend/api/.
        # If Django URLs are like /v1/endpoint, and Nginx location is /api/, then proxy_pass could be http://django_backend/ and use rewrite.
        # Assuming Django URLs are already prefixed with /api/.
        proxy_pass http://django_backend/api/; # Forward to the upstream group defined earlier. Ensure trailing slash consistency.

        # Set headers to pass information to the backend application.
        proxy_set_header Host $host;                         # Pass the original host header from the client.
        proxy_set_header X-Real-IP $remote_addr;             # Pass the real client IP address.
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # Append client IP to the list of forwarded IPs.
        proxy_set_header X-Forwarded-Proto $scheme;          # Pass the original request scheme (http or https).

        # Recommended settings for reverse proxies.
        proxy_redirect off;                                  # Do not let backend modify Location headers.
        proxy_buffering on;                                  # Enable buffering of responses from the proxied server.
        proxy_buffer_size 16k;                               # Size of the buffer used for reading the first part of the response.
        proxy_busy_buffers_size 24k;                         # Maximum size of buffers that can be busy sending a response to the client.
        proxy_temp_file_write_size 24k;                      # Limit the size of temporary files.
        proxy_connect_timeout 90s;                           # Timeout for establishing a connection with the proxied server.
        proxy_send_timeout 90s;                              # Timeout for transmitting a request to the proxied server.
        proxy_read_timeout 90s;                              # Timeout for reading a response from the proxied server.
        
        # For WebSockets (if your Django app uses them, e.g., with Django Channels)
        # proxy_http_version 1.1;
        # proxy_set_header Upgrade $http_upgrade;
        # proxy_set_header Connection "upgrade";
    }

    # Optional: Deny access to hidden files (e.g., .htaccess, .git)
    location ~ /\. {
        deny all;
    }

    # Optional: Custom error pages
    # error_page 500 502 503 504 /50x.html;
    # location = /50x.html {
    #     root /usr/share/nginx/html; # Or your custom error page location
    # }
}

# It's good practice to include gzip compression for textual data.
# This can also be in the main http block in a global nginx.conf.
# gzip on;
# gzip_vary on;
# gzip_proxied any;
# gzip_comp_level 6;
# gzip_buffers 16 8k;
# gzip_http_version 1.1;
# gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript image/svg+xml;
